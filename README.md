# simple-cpp-template

## Использование шаблона

В корне проекта:

1. Выполнить конфигурацию проекта и положить конфиги в каталог `build`:
```shell
cmake -B build
```
- опцией `-G` можно указать утилиту для сборки. Например, на Windows удобно использовать Ninja (предварительно установив его) вот так:
```shell
cmake -B build -G Ninja
```

2. Собрать проект с использованием подготовленной конфигурации в каталоге `build`:
```shell
cmake --build build
```

3. Запустить собранный проект из каталога с исполнаяемыми файлами:
```shell
./build/app/app
```

При желании можно настроить тесты, например, добавив модуль `test` по аналогии с
`app`, где будут подключаться Google Tests.

- - -

## Комментарии

- В проекте показан пример использования CMake для сборки проекта на языке C и C++ (см. [app/CMakeLists.txt](./app/CMakeLists.txt)).

- Можно использовать свой простой Makefile вместо CMake или сделать Makefile для запуска CMake.

- Может потребоваться сделать `export CXX=clang++` и `export СС=clang`, чтобы CMake использовал нужные компиляторы.

## Задание

Для оптимизации работы с блочными устройствами в ОС существует кэш страниц с данными, которыми мы производим операции чтения и записи на диск. Такой кэш позволяет избежать высоких задержек при повторном доступе к данным, так как операция будет выполнена с данными в RAM, а не на диске (вспомним пирамиду памяти).

В данной лабораторной работе необходимо реализовать блочный кэш в пространстве пользователя в виде динамической библиотеки (dll или so). Политику вытеснения страниц и другие элементы задания необходимо получить у преподавателя.

При выполнении работы необходимо реализовать простой API для работы с файлами, предоставляющий пользователю следующие возможности:

1. Открытие файла по заданному пути файла, доступного для чтения. Процедура возвращает некоторый хэндл на файл. Пример:  
    `int lab2_open(const char *path).`
2. Закрытие файла по хэндлу. Пример:  
    `int lab2_close(int fd).`
3. Чтение данных из файла. Пример:  
    `ssize_t lab2_read(int fd, void buf[.count], size_t count).`
4. Запись данных в файл. Пример:  
    `ssize_t lab2_write(int fd, const void buf[.count], size_t count).`
5. Перестановка позиции указателя на данные файла. Достаточно поддержать только абсолютные координаты. Пример:  
    ​​​​​​​`off_t lab2_lseek(int fd, off_t offset, int whence).`
6. Синхронизация данных из кэша с диском. Пример:  
    `int lab2_fsync(int fd).`

  
Операции с диском разработанного блочного кеша должны производиться в обход page cache используемой ОС.

В рамках проверки работоспособности разработанного блочного кэша необходимо адаптировать указанную преподавателем программу-загрузчик из ЛР 1, добавив использование кэша. Запустите программу и убедитесь, что она корректно работает. Сравните производительность до и после.

## Ограничения

- Программа (комплекс программ) должна быть реализован на языке C или C++.
- Запрещено использовать высокоуровневые абстракции над системными вызовами. Необходимо использовать, в случае Unix, процедуры libc.
# Отчет 

`ФИО студента:` Чмурова Мария Владиславовна 

`Номер группы:` P3332

`Вариант ЛР №2:` FIFO

`ФИО практика:` Осипов Святослав Владимирович

# Лабораторная работа №2

Структура для хранения страницы кэша и блока кэша: 

```c++
struct CachedPage {
  off_t page_offset;
  std::vector<char> data;
  bool is_changed;
  int fd;
};

struct BlockCache {
  size_t block_size;                   
  size_t max_cache_size;                
  std::unordered_map<off_t, std::list<CachedPage>::iterator> cache_map; 
  std::list<CachedPage> cache;   
  std::unordered_map<int, off_t> fd_offsets;
  std::unordered_map<int, int> file_descriptors; 
};
```

Программа нагрузчик в ЛР №1: 

io-thpt-read - Измерение пропускной способности на последовательное чтение накопителя с размерами блока Block Size. Block Size -16K

Время выполнения с пользовательским кэшэм для файла 50 МБ: 

```c++
Время с кэшем: 219.77 ms
```

Время выполнения без использования кэша с флагом `O_DIRECT`: 
```c++
Время без кэша: 563.463 ms
```

Время работы с кэшем меньше примерно в 2.5 раза. Это вызвано тем, что при работе с кэшем совершается меньше системных вызовов для чтения данных, так как они сохраняются в памяти. 

Наглядно: 

1. Вызов strace -c для программы с кэшем:
```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 99.09    0.497641           7     64010           pread64
  0.21    0.001033          51        20         4 openat
  0.17    0.000869         869         1           execve
  0.13    0.000649          13        48           brk
  0.12    0.000613          27        22           mmap
  0.07    0.000341          28        12           mprotect
  0.05    0.000247          15        16           close
```
2. Вызов для программы без кэша: 
```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 99.95    3.299972          12    256015           read
  0.02    0.000544          27        20         4 openat
  0.01    0.000356          35        10           write
  0.01    0.000252          15        16           close
  0.01    0.000217           9        22           mmap
```

Таким образом, наглядно видно, что количество вызовов read: 64 010 и 256 015 - примерно в 4 раза меньше вызовов на чтение, то есть программа будет работать быстрее, так как тратит меньше времени на обращение в файлу. 
